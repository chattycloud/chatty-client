import React from "react";
import io, { Socket } from "socket.io-client";
import axios, { AxiosInstance } from "axios";
import md5 from "md5";
import { format } from "date-fns";

/**
 *
 *  ___ _  _ _   _ __  __ ___ ___    _ _____ ___ ___  _  _ ___
 * | __| \| | | | |  \/  | __| _ \  /_\_   _|_ _/ _ \| \| / __|
 * | _|| .` | |_| | |\/| | _||   / / _ \| |  | | (_) | .` \__ \
 * |___|_|\_|\___/|_|  |_|___|_|_\/_/ \_\_| |___\___/|_|\_|___/
 */

enum eAppPricing {
  FREE = "FREE",
  PRODUCTION = "PRODUCTION",
  ADVANCED = "ADVANCED",
  ENTERPRISE = "ENTERPRISE",
}

enum eMemberPermission {
  SUPER = "SUPER",
  WRITE = "WRITE",
  READ = "READ",
}

enum eMessageType {
  TEXT = "TEXT",
  FILE = "FILE",
  JSON = "JSON",
}

enum eMessageBy {
  USER = "USER",
  ADMIN = "ADMIN",
  SYSTEM = "SYSTEM",
}

enum eNotification {
  CHATTY_USER_MESSAGE = "CHATTY_USER_MESSAGE",
  CHATTY_ADMIN_MESSAGE = "CHATTY_ADMIN_MESSAGE",
  CHATTY_SYSTEM_MESSAGE = "CHATTY_SYSTEM_MESSAGE",
}

export const SupportedImageFormat = [
  "image/png",
  "image/jpg",
  "image/jpeg",
  "image/gif",
  "image/webp",
];
export const SupportedVideoFormat = ["video/mp4", "video/webm"];
export const SupportedUploadSize = 20000000;

export enum eChattyEvent {
  CONNECT = "connection",
  CONNECT_DONE = "connect_done",
  CONNECT_FAIL = "connect_fail",

  DISCONNECT = "disconnect",
  DISCONNECT_DONE = "disconnect_done",
  DISCONNECT_FAIL = "disconnect_fail",

  REFRESH_CHAT = "refresh_chat",
  REFRESH_CHAT_DONE = "refresh_chat_done",
  REFRESH_CHAT_FAIL = "refresh_chat_fail",

  RECEIVE_MESSAGE = "receive_message",

  FETCH_MESSAGES = "fetch_messages",
  FETCH_MESSAGES_DONE = "fetch_messages_done",
  FETCH_MESSAGES_FAIL = "fetch_messages_fail",

  UPDATE_MESSAGES = "update_message",

  SEND_MESSAGE = "send_message",
  SEND_MESSAGE_DONE = "send_message_done",
  SEND_MESSAGE_FAIL = "send_message_fail",
  SEND_MESSAGE_RETRY = "send_message_retry",

  DELETE_MESSAGE = "delete_message",
  DELETE_MESSAGE_DONE = "delete_message_done",
  DELETE_MESSAGE_FAIL = "delete_message_fail",

  MARK_AS_READ = "mark_as_read",
  MARK_AS_READ_DONE = "mark_as_read_done",
  MARK_AS_READ_FAIL = "mark_as_read_fail",
}

/**
 *
 *   ___ _  _ ___  _____  __  ___ ___ ___ _  _   _ _____ _   _ ___ ___ ___
 *  |_ _| \| |   \| __\ \/ / / __|_ _/ __| \| | /_\_   _| | | | _ \ __/ __|
 *   | || .` | |) | _| >  <  \__ \| | (_ | .` |/ _ \| | | |_| |   / _|\__ \
 *  |___|_|\_|___/|___/_/\_\ |___/___\___|_|\_/_/ \_\_|  \___/|_|_\___|___/
 */

interface iTranslationIndexSignature {
  [key: string]: string;
}

/**
 *
 *   ___ ___ _  _____ ___ ___   ___ _  _ _____ ___ ___ ___ _   ___ ___ ___
 *  | __|_ _| ||_   _| __| _ \ |_ _| \| |_   _| __| _ \ __/_\ / __| __/ __|
 *  | _| | || |__| | | _||   /  | || .` | | | | _||   / _/ _ \ (__| _|\__ \
 *  |_| |___|____|_| |___|_|_\ |___|_|\_| |_| |___|_|_\_/_/ \_\___|___|___/
 */

interface iMembersFilter {
  group?: string;
  keyword?: string; // keyword for searching member name
  ChatId?: string;
}

interface iChatsFilter {
  group?: string;
  keyword?: string; // keyword for searching chat name
  data?: { [key: string]: any }; // data for searching chat data
  MemberId?: string; // if MemberId is specified, get chats only MemberId included. if not, get all chats created
  page?: number;
  pageLimit?: number; // default: 50
}

/**
 *
 *   ___  ___   ___    ___   _   ___    ___ _  _ _____ ___ ___ ___ _   ___ ___ ___
 *  | _ \/_\ \ / / |  / _ \ /_\ |   \  |_ _| \| |_   _| __| _ \ __/_\ / __| __/ __|
 *  |  _/ _ \ V /| |_| (_) / _ \| |) |  | || .` | | | | _||   / _/ _ \ (__| _|\__ \
 *  |_|/_/ \_\_| |____\___/_/ \_\___/  |___|_|\_| |_| |___|_|_\_/_/ \_\___|___|___/
 */

interface iInitPayload {
  apiKey: string;
  member: {
    id: string;
    name: string;
    avatar?: string;
    deviceToken?: string;
    language?: string;
    country?: string;
    group?: string;
    data?: any;
  };
}

interface iExitPayload {
  deleteMember?: boolean; // Deleting member. It's useful when application user delete account. Default value is false.
}

interface iConnectionPayload {
  id?: string; // The chat ID, obtained as a part of the server's response at chatlist screen.
  distinctKey?: string; // The md5 distinctKey, which is generated by combining chat member's IDs or a user-defined custom key, serves as a unique identifier for each chat.
  members?: string[];
  name?: string;
  image?: string;
  group?: string;
  data?: any;
}

interface iDevicePayload {
  platform: string;
  language: string;
  product: string;
  userAgent: string;
  sdkVersion?: string;
}

interface iCreateAdminMessagePayload {
  distinctKey: string;
  name?: string;
  image?: string;
  group?: string;
  data?: any;
  members?: Array<string>;
  message?: {
    text?: string;
    json?: object;
    by?: eMessageBy.ADMIN;
  };
}

interface iCreateChatPayload {
  distinctKey?: string;
  name?: string;
  image?: string;
  group?: string;
  data?: any;
  members?: Array<string>;
  message?: {
    text?: string;
    json?: object;
    by?: eMessageBy.ADMIN;
  };
}

interface iUpdateChatPayload {
  distinctKey?: string;
  name?: string;
  image?: string;
  group?: string;
  data?: any;
  members?: Array<string>;
  message?: {
    text?: string;
    json?: object;
    by?: eMessageBy.ADMIN;
  };
}

/**
 *
 *   ___ ___ ___ ___  ___  _  _ ___ ___   ___ _  _ _____ ___ ___ ___ _   ___ ___ ___
 *  | _ \ __/ __| _ \/ _ \| \| / __| __| |_ _| \| |_   _| __| _ \ __/_\ / __| __/ __|
 *  |   / _|\__ \  _/ (_) | .` \__ \ _|   | || .` | | | | _||   / _/ _ \ (__| _|\__ \
 *  |_|_\___|___/_|  \___/|_|\_|___/___| |___|_|\_| |_| |___|_|_\_/_/ \_\___|___|___/
 */

interface iApp {
  id: string;
  name: string;
  pricing: eAppPricing;
  image: { uri: string };
  language: string;
  country: string;
  enableTranslation: boolean;
  enableJoinMessage: boolean;
  enableLeaveMessage: boolean;
  enableInviteMessage: boolean;
  enableExcludeMessage: boolean;
  enableImageUpload: boolean;
  enableVideoUpload: boolean;
  chatCapacity: number;
  chatPageLimit: number;
  chatListPageLimit: number;
  thumbnailSize: number;
  notificationSound: string;
  maxImageSize: number;
  maxVideoSize: number;
  multipleUploadCount: number;
  createdAt: Date;
  updatedAt: Date;
}

interface iMember {
  id: string;
  name: string;
  language: string;
  country: string;
  avatar: string;
  device: iDevicePayload;
  deviceToken: string;
  group: string;
  permission: eMemberPermission;
  data: any | null;
  createdAt: Date;
  updatedAt: Date;
}

interface iMessage {
  id: string;
  text: string | null;
  files: Array<{ uri: string }>;
  json: any | null;
  type: eMessageType;
  translation: iTranslationIndexSignature | null;
  by: eMessageBy;
  readReceipt: number;
  createdAt: Date;
  updatedAt: Date;
  sender: iMember | null;
  isSending: boolean | undefined;
}

interface iChat {
  id: string;
  name: string;
  image: { uri: string };
  lastMessage: iMessage | undefined;
  data: any | null;
  distinctKey: string | null;
  group: string;
  createdAt: Date;
  updatedAt: Date;
  members: Array<iMember>;
  missedCount: number;
}

interface iMissedCount {
  total: number; // total missedCount
  group: Array<{ name: string; count: number }>; // missedCount by group name
}

interface iNotificationData {
  type: eNotification;
  id: string; // chatId or messageId
  group: string; // chat group
}

class Chatty {
  static apiKey: string | undefined;
  static app: iApp | undefined;
  static member: iMember | undefined;
  static missedCount: iMissedCount | undefined;
  static axiosInstance: AxiosInstance;

  static async init({ apiKey, member }: iInitPayload) {
    try {
      if (!apiKey)
        return Promise.reject({
          message: ":: ChattyClient init() apiKey is required.",
        });
      this.axiosInstance = getAxiosInstance(apiKey);
      this.apiKey = apiKey;
      this.app = await this.getApp();
      this.axiosInstance.defaults.headers.common["AppId"] = this.app.id;
      this.member = await this.upsertMember(member.id, {
        name: member.name,
        avatar: member.avatar,
        group: member.group,
        data: member.data,
        deviceToken: member.deviceToken,
        device: {
          platform: navigator.platform,
          language: navigator.language,
          product: navigator.product,
          userAgent: navigator.userAgent,
          sdkVersion: process.env.VERSION,
        },
      });
      this.axiosInstance.defaults.headers.common["MemberId"] = this.member.id;
      if (this.app && this.member) {
        ChattyEventEmitter.emit("initialized", { initialized: true });
        console.debug(":: ChattyClient Initialized !!");
        console.debug(":: ChattyClient App > ", this.app);
        console.debug(":: ChattyClient Member > ", this.member);
      }
    } catch (error: any) {
      return Promise.reject({
        message: ":: ChattyClient init fail - " + error.message,
      });
    }
  }

  static async exit({ deleteMember = false }: iExitPayload) {
    try {
      if (this.member) {
        if (deleteMember) {
          await this.deleteMember(this.member.id);
        } else {
          await this.upsertMember(this.member.id, { deviceToken: "" });
        }
      }

      this.apiKey = undefined;
      this.app = undefined;
      this.member = undefined;
      this.axiosInstance.defaults.headers.common = {};
      console.debug(":: ChattyClient exit success");
    } catch (error: any) {
      return Promise.reject({
        message: ":: ChattyClient exit fail - " + error.message,
      });
    }
  }

  private static async getApp(): Promise<iApp> {
    const { data } = await this.axiosInstance.get(`/apps`, { headers: {} });
    return data;
  }

  static async getChats(filter: iChatsFilter): Promise<iChat[]> {
    const { data } = await this.axiosInstance.get("/chats", { params: filter });
    return data;
  }

  static async createChat(payload: iCreateChatPayload): Promise<iChat> {
    const { data } = await this.axiosInstance.post("/chats", {
      distinctKey: payload.distinctKey,
      name: payload.name,
      image: payload.image ? { uri: payload.image } : undefined,
      group: payload.group,
      data: payload.data,
      Members: payload.members?.map((MemberId: string) => ({
        MemberId: MemberId,
        AppId: this.app?.id,
      })),
      Messages: payload.message && [
        {
          ...payload.message,
          AppId: this.app?.id,
          type: payload.message.json ? eMessageType.JSON : eMessageType.TEXT,
        },
      ],
    });

    return data;
  }

  static async leaveChat(ChatId: string): Promise<Boolean> {
    const { data } = await this.axiosInstance.delete<Boolean>(`/chatmember`, {
      params: { ChatId: ChatId, MemberId: Chatty.member?.id },
    });
    return data;
  }

  static async updateChat(id: string, payload: iUpdateChatPayload): Promise<iChat> {
    const { data } = await this.axiosInstance.put(`/chats/${id}`, {
      distinctKey: payload.distinctKey,
      name: payload.name,
      image: payload.image ? { uri: payload.image } : undefined,
      group: payload.group,
      data: payload.data,
      Members: payload.members?.map((MemberId: string) => ({
        MemberId: MemberId,
        AppId: this.app?.id,
      })),
      Messages: payload.message && [
        {
          ...payload.message,
          AppId: this.app?.id,
          type: payload.message.json ? eMessageType.JSON : eMessageType.TEXT,
        },
      ],
    });
    return data;
  }

  static async createAdminMessage(
    payload: iCreateAdminMessagePayload
  ): Promise<iChat> {
    const { data } = await this.axiosInstance.put(`/chats`, {
      distinctKey: payload.distinctKey,
      name: payload.name,
      image: payload.image ? { uri: payload.image } : undefined,
      group: payload.group,
      data: payload.data,
      Members: payload.members?.map((MemberId: string) => ({
        MemberId: MemberId,
        AppId: this.app?.id,
      })),
      Messages: payload.message && [
        {
          ...payload.message,
          AppId: this.app?.id,
          type: payload.message.json ? eMessageType.JSON : eMessageType.TEXT,
          by: eMessageBy.ADMIN,
        },
      ],
    });

    return data;
  }

  static async getMembers(filter: iMembersFilter): Promise<Array<iMember>> {
    const { data } = await this.axiosInstance.get(`/members`, {
      params: filter,
    });
    return data;
  }

  private static async upsertMember(id: string, member: {
    name?: string;
    avatar?: string;
    group?: string;
    data?: any;
    deviceToken?: string;
    device?: iDevicePayload;
  }): Promise<iMember> {
    const { data } = await this.axiosInstance.put(`/members/${id}`, member);
    return data;
  }

  private static async deleteMember(id: string): Promise<Boolean> {
    return await this.axiosInstance.delete(`/members/${id}`);
  }

  static generateDistinctKey(...payload: Array<string>): string | undefined {
    if (!payload || !payload.length) {
      console.warn(
        ":: ChattyClient generateDistinctKey error - param data is undefined"
      );
      return;
    }

    if (!this.app) {
      console.warn(
        ":: ChattyClient generateDistinctKey error - Chatty was not initialized"
      );
      return;
    }

    // add AppId to hash elements
    payload.push(this.app.id);

    const inputValue = payload.sort().toString();

    if (inputValue.length >= 255) {
      console.warn(
        ":: ChattyClient generateDistinctKey error - md5 input string is too long"
      );
      return;
    }

    return md5(inputValue);
  }

  static fetchMissedCount = async (): Promise<iMissedCount> => {
    if (!this.app || !this.member)
      return Promise.reject({
        message:
          ":: ChattyClient fetchMissedCount fail - Chatty was not initialized",
      });
    const { data } = await this.axiosInstance.get(`/missed-count`);
    console.debug(":: ChattyClient fetchMissedCount", data);
    Chatty.setMissedCount(data);
    return data;
  };

  static getMissedCount = (): iMissedCount => {
    return this.missedCount;
  };

  static setMissedCount = (missedCount: iMissedCount) => {
    this.missedCount = missedCount;
    ChattyEventEmitter.emit("missed-count", missedCount);
  };

  static upload = async (
    files: Array<{ uri: string; type: string }>
  ): Promise<Array<{ uri: string }>> => {
    return new Promise(async (resolve, reject) => {
      try {
        if (!this.app || !this.member)
          return reject({
            message: ":: ChattyClient upload fail - Chatty was not initialized",
          });

        // TODO file type checking
        files.map((file: { uri: string; type: string }) => {
          if (!SupportedImageFormat.includes(file.type)) {
            return reject({ message: ":: ChattyClient Unsupported file type" });
          }
        });

        const result = await Promise.all(
          files.map(async (file: any) => {
            const form = new FormData();
            form.append("file", file);

            const uploadUrl = await this.axiosInstance?.get("/uploadurl");
            if (!uploadUrl?.data) {
              reject({
                message: ":: ChattyClient upload - Getting uploadUrl failed",
              });
            }

            const uploaded = await axios.post(uploadUrl?.data, form, {
              headers: {
                "Content-Type": "multipart/form-data",
                Accept: "application/json",
              },
            });

            if (uploaded?.data?.result) {
              const baseurl = uploaded.data.result.variants[0].split(
                uploaded.data.result.id
              )[0];
              return {
                uri:
                  baseurl +
                  uploaded.data.result.id +
                  "/" +
                  this.app?.thumbnailSize,
              };
            } else {
              return { uri: "" };
            }
          })
        );

        resolve(result);
      } catch (error: any) {
        reject(error);
      }
    });
  };
}

class ChattyEventEmitter {
  static listeners: { [event: string]: Array<(data?: any) => void> } = {};

  static on(event: string, callback: (data?: any) => void): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }

  static off(event: string, callback: (data?: any) => void): void {
    if (!this.listeners[event]) return;

    this.listeners[event] = this.listeners[event].filter(
      (listener) => listener !== callback
    );
  }

  static emit(event: string, data?: any): void {
    if (!this.listeners[event]) return;

    this.listeners[event].forEach((callback) => callback(data));
  }
}

const getAxiosInstance = (ApiKey: string): AxiosInstance => {
  const instance = axios.create();
  instance.defaults.baseURL = process.env.API_URL;
  instance.defaults.headers.common["ApiKey"] = ApiKey;
  instance.defaults.headers.common["Content-Type"] = "application/json";
  instance.interceptors.request.use(
    (request) => request,
    (error) =>
      Promise.reject({ ...error, message: ":: ChattyClient Request Error" })
  );
  instance.interceptors.response.use(
    (response) => response,
    (error) =>
      Promise.reject(
        error.response
          ? {
            message: `:: ChattyClient Error - ${error.response.data?.message}`,
          }
          : "Network Error"
      )
  );
  return instance;
};

const useIsInitialized = (): boolean => {
  const [initialized, setInitialized] = React.useState<boolean>(
    Chatty.apiKey && Chatty.app && Chatty.member ? true : false
  );
  React.useEffect(() => {
    if (initialized) return;
    const handleInitialized = (data: any) => {
      setInitialized(data.initialized);
    };
    ChattyEventEmitter.on("initialized", handleInitialized);
    return () => {
      console.debug(
        ":: ChattyClient useInitialized - remove listener initialized"
      );
      ChattyEventEmitter.off("initialized", handleInitialized);
    };
  }, []);
  return initialized;
};

const useMissedCount = (deps: any[]): iMissedCount | undefined => {
  const initialized = useIsInitialized();
  const [count, setCount] = React.useState<iMissedCount>(
    Chatty.getMissedCount()
  );

  React.useEffect(() => {
    if (!initialized) return;

    Chatty.fetchMissedCount().then(() => setCount(Chatty.getMissedCount()));
  }, [initialized, ...deps]);

  React.useEffect(() => {
    const updateMissedCount = (data: iMissedCount) => {
      setCount(data);
    };
    ChattyEventEmitter.on("missed-count", updateMissedCount);

    return () => {
      ChattyEventEmitter.off("missed-count", updateMissedCount);
    };
  }, []);

  return count;
};

const useSocket = (payload: iConnectionPayload): Socket | null => {
  const [socket, setSocket] = React.useState<Socket | null>(null);

  React.useEffect(() => {
    if (socket) return;

    if (!Chatty.apiKey || !Chatty.app || !Chatty.member) {
      console.warn(":: ChattyClient - Chatty was not initialized");
      return;
    }

    console.debug(":: ChattyClient - socket connecting");
    const newSocket = io(`${process.env.SOCKET_URL}/chat.${Chatty.app?.name}`, {
      auth: {
        apiKey: Chatty.apiKey,
        MemberId: Chatty.member?.id,
        AppId: Chatty.app?.id,
        payload: payload,
      },
    });

    setSocket(newSocket);

    return () => {
      newSocket.close();
      setSocket(null);
      console.debug(":: ChattyClient - socket disconnected");
    };
  }, []);

  return socket;
};

/**
 *
 * @param {iConnectionPayload} payload
 * @returns {
 * {
 *  chat: iChat,
 *  messages: { [date: string]: { [timeSenderIdKey: string]: iMessage[] } },
 *  isLoading: boolean,
 *  isFetching: boolean,
 *  fetchNextMessages: () => void,
 *  sendMessage: (message: string | object | Array<{ uri: string, type: string }>) => void,
 *  refresh: () => void,
 *  error: { message: string } | undefined,
 * }
 * }
 */
const useChat = (
  payload: iConnectionPayload
): {
  chat: iChat;
  messages: { [date: string]: { [timeSenderIdKey: string]: iMessage[] } };
  isLoading: boolean;
  isFetching: boolean;
  fetchNextMessages: () => void;
  sendMessage: (
    message: string | object | Array<{ uri: string; type: string }>
  ) => void;
  refresh: () => void;
  error: { message: string } | undefined;
} => {
  const [chat, setChat] = React.useState<iChat>();
  const [messages, setMessages] = React.useState<iMessage[]>([]);
  const [hasNext, setHasNext] = React.useState<boolean>(false);
  const [isLoading, setIsLoading] = React.useState<boolean>(true);
  const [isFetching, setIsFetching] = React.useState<boolean>(false);
  const [error, setError] = React.useState<{ message: string }>();
  const socket = useSocket(payload);

  const formattedMessages = React.useMemo(() => {
    let groupedMessages: {
      [date: string]: { [timeSenderIdKey: string]: iMessage[] };
    };

    messages.map((message) => {
      const dateKey = format(new Date(message.createdAt), "PP");
      const timeKey = format(new Date(message.createdAt), "p");
      const SenderIdKey = message.sender?.id!;
      const timeSenderIdKey = `${timeKey}@${SenderIdKey}`;

      if (!groupedMessages) {
        groupedMessages = {};
      }

      if (!groupedMessages[dateKey]) {
        groupedMessages[dateKey] = {};
      }
      if (!groupedMessages[dateKey][timeSenderIdKey]) {
        groupedMessages[dateKey][timeSenderIdKey] = [];
      }

      groupedMessages[dateKey][timeSenderIdKey].unshift(message); // here, use unshift instead of using reverse() at ui component
    });

    return groupedMessages;
  }, [messages]);

  React.useEffect(() => {
    if (!socket) return;

    // CONNECT
    socket.on(
      eChattyEvent.CONNECT_DONE,
      (data: {
        chat: iChat;
        refresh: boolean;
        hasNext: boolean;
        messages: Array<iMessage>;
      }) => {
        setChat(data.chat);
        setMessages(data.messages!);
        setHasNext(data.hasNext!);
        socket.emit(eChattyEvent.MARK_AS_READ);
        setIsLoading(false);
        setError(undefined);
        console.debug(":: ChattyClient connected");
      }
    );
    socket.on(eChattyEvent.CONNECT_FAIL, (error: any) => {
      console.warn(":: ChattyClient connection fail", error);
      setIsLoading(false);
      setError(error);
    });

    // FETCH_MESSAGES
    socket.on(
      eChattyEvent.FETCH_MESSAGES_DONE,
      (data: {
        refresh: boolean;
        hasNext: boolean;
        messages: Array<iMessage>;
      }) => {
        if (data.refresh) {
          setMessages(data.messages!);
          setHasNext(data.hasNext!);
        } else {
          setMessages((oldMessages) => {
            const oldMessagesMap = new Map(
              oldMessages.map((e) => [e["id"], e])
            );
            const newMessagesMap = new Map(
              data.messages?.map((e) => [e["id"], e])
            );
            const messagesMap = new Map([...oldMessagesMap, ...newMessagesMap]);
            return Array.from(messagesMap.values());
          });
          setHasNext(data.hasNext!);
        }
        setIsFetching(false);
        setError(undefined);
        // socket.emit(eChattyEvent.MARK_AS_READ); // deprecated.
      }
    );
    socket.on(eChattyEvent.FETCH_MESSAGES_FAIL, (error: any) => {
      console.warn(":: ChattyClient fetch messages fail", error);
      setIsFetching(false);
      setError(error);
    });

    // SEND_MESSAGE
    socket.on(eChattyEvent.SEND_MESSAGE_DONE, (data: any) => {
      console.debug(":: ChattyClient send message done", data);
      setError(undefined);
      setMessages((oldMessages) => {
        const oldMessagesMap = new Map(oldMessages.map((e) => [e["id"], e]));
        const newMessagesMap = new Map(
          data.message && [[data.message["id"], data.message]]
        );
        const messagesMap = new Map([...oldMessagesMap, ...newMessagesMap]);
        return Array.from(messagesMap.values());
      });
    });
    socket.on(eChattyEvent.SEND_MESSAGE_RETRY, (data: { retry: number }) => {
      console.debug(":: ChattyClient send message retry", data);
      socket.emit(eChattyEvent.SEND_MESSAGE, data);
    });
    socket.on(eChattyEvent.SEND_MESSAGE_FAIL, (error: any) => {
      console.warn(":: ChattyClient send message fail", error);
      setError(error);
    });

    // RECEIVE_MESSAGE
    socket.on(eChattyEvent.RECEIVE_MESSAGE, (data: any) => {
      console.debug(":: ChattyClient receive message", data);
      setMessages((oldMessages) => {
        const oldMessagesMap = new Map(oldMessages.map((e) => [e["id"], e]));
        const newMessagesMap = new Map(
          data.message && [[data.message["id"], data.message]]
        );
        const messagesMap = new Map([...newMessagesMap, ...oldMessagesMap]);
        return Array.from(messagesMap.values());
      });
      setError(undefined);
      socket.emit(eChattyEvent.MARK_AS_READ);
    });

    // MARK_AS_READ
    socket.on(eChattyEvent.MARK_AS_READ_DONE, () => {
      console.debug(":: ChattyClient mark as read done");
      Chatty.fetchMissedCount();
    });
    socket.on(eChattyEvent.MARK_AS_READ_FAIL, (error: any) => {
      console.debug(":: ChattyClient mark as read fail", error);
      setError(error);
    });

    // UPDATE_MESSAGES
    socket.on(
      eChattyEvent.UPDATE_MESSAGES,
      (data: { messages: Array<iMessage> }) => {
        console.debug(":: ChattyClient update messages", data);
        // readReceipt가 변경되었거나 메세지내용이 삭제또는 변경된경우 update하기 위해 발생되는 이벤트 (서버주도로 발생)
        setMessages((oldMessages) => {
          const oldMessagesMap = new Map(oldMessages.map((e) => [e["id"], e]));
          const newMessagesMap = new Map(
            data.messages?.map((e) => [e["id"], e])
          );
          const messagesMap = new Map([...oldMessagesMap, ...newMessagesMap]);
          return Array.from(messagesMap.values());
        });
        setError(undefined);
      }
    );

    // REFRESH_CHAT
    socket.on(eChattyEvent.REFRESH_CHAT_DONE, (data: { chat: iChat }) => {
      console.debug(":: ChattyClient refresh chat done", data);
      setChat(data.chat);
      setError(undefined);
    });

    return () => {
      socket.off(eChattyEvent.CONNECT_DONE);
      socket.off(eChattyEvent.CONNECT_FAIL);
      socket.off(eChattyEvent.FETCH_MESSAGES_DONE);
      socket.off(eChattyEvent.FETCH_MESSAGES_FAIL);
      socket.off(eChattyEvent.SEND_MESSAGE_DONE);
      socket.off(eChattyEvent.SEND_MESSAGE_RETRY);
      socket.off(eChattyEvent.SEND_MESSAGE_FAIL);
      socket.off(eChattyEvent.RECEIVE_MESSAGE);
      socket.off(eChattyEvent.MARK_AS_READ_DONE);
      socket.off(eChattyEvent.MARK_AS_READ_FAIL);
      socket.off(eChattyEvent.UPDATE_MESSAGES);
      socket.off(eChattyEvent.REFRESH_CHAT_DONE);
      console.debug(":: ChattyClient disconnected");
    };
  }, [socket]);

  const fetchNextMessages = () => {
    if (hasNext) {
      setIsFetching(true);
      socket.emit(eChattyEvent.FETCH_MESSAGES, { refresh: false });
    }
  };

  const refreshChat = () => {
    setIsLoading(true);
    socket.emit(eChattyEvent.REFRESH_CHAT);
  };

  const isTextMessage = (
    message: string | object | Array<{ uri: string; type: string }>
  ): message is string => {
    return typeof message === "string";
  };
  const isFileMessage = (
    message: string | object | Array<{ uri: string; type: string }>
  ): message is Array<{ uri: string; type: string }> => {
    return Array.isArray(message);
  };
  const isJsonMessage = (
    message: string | object | Array<{ uri: string; type: string }>
  ): message is object => {
    return (
      typeof message === "object" && message !== null && !Array.isArray(message)
    );
  };

  const sendMessage = async (
    message: string | object | Array<{ uri: string; type: string }>
  ) => {
    const id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function (c) {
        var r = (Math.random() * 16) | 0,
          v = c == "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      }
    );
    const now = new Date();
    const type = isTextMessage(message)
      ? eMessageType.TEXT
      : isJsonMessage(message)
        ? eMessageType.JSON
        : eMessageType.FILE;
    const text = isTextMessage(message)
      ? message
      : isFileMessage(message)
        ? "File message"
        : "JSON message";

    const tempMessage: iMessage = {
      id: id,
      text: text,
      files: isFileMessage(message) ? message : undefined,
      json: isJsonMessage(message) ? message : undefined,
      type: type,
      by: eMessageBy.USER,
      translation: null,
      readReceipt: 0,
      createdAt: now,
      updatedAt: now,
      sender: Chatty.member,
      isSending: true,
    };

    setMessages((oldMessages) => {
      const oldMessagesMap = new Map(oldMessages.map((e) => [e["id"], e]));
      const newMessagesMap = new Map([[tempMessage["id"], tempMessage]]);
      const messagesMap = new Map([...newMessagesMap, ...oldMessagesMap]);
      return Array.from(messagesMap.values());
    });

    socket.emit(eChattyEvent.SEND_MESSAGE, {
      id: id,
      text: text,
      files: isFileMessage(message) ? await Chatty.upload(message) : undefined,
      json: isJsonMessage(message) ? message : undefined,
      type: type,
      by: eMessageBy.USER,
      createdAt: now,
      retry: 5,
    });
  };

  return {
    chat,
    messages: formattedMessages,
    error,
    isLoading,
    isFetching,
    fetchNextMessages,
    sendMessage,
    refresh: refreshChat,
  };
};

export {
  Chatty,
  useIsInitialized,
  useMissedCount,
  useChat,
  eMessageBy,
  eMessageType,
  eNotification,
  iMissedCount,
  iChat,
  iMessage,
  iMember,
};
